//  File Comments  ////=========================================================================///* FILENAME: 3Dvlt_macro_cp_table.c *//* VERSION: 1 (2011 Oct 29 - ...)            More terms have been added, due to the refined derivation of cp.            New name: from vlt_HeatCap_P.c to 3Dvlt_macro_cp.c            C is now out of the recursion relations, normal settings *//* AUTHOR: Andrew Forrester <aforrester@ucla.edu> *//* DESCRIPTION:   * This C program calculates the (length-scale-dependent) molar specific heat capacity at constant pressure c_P (cp) (and other thermodynamic quantities) of a system of liquid helium-4 (4He) at the macroscopic length scale, at various temperatures and pressures.   * The system is a spherical region (of variable diameter) of liquid 4He at some constant pressure, near or below the critical transition temperature Tc (which depends on pressure) separating normal fluid and superfluid (aka the lambda temperature).   * The program uses the vortex-loop theory of the superfluid phase transition (i.e., its differential recursion relations) of Gary A. Williams and Subodh R. Shenoy and a 4th-order Runge-Kutta integration method to calculate (length-scale-dependent) thermodynamic quantities (especially cp) of the system at a set of temperatures {Tn}, at various length scales (no greater than a length scale corresponding to the the limit K<Kthresh), and at some pressure (which also determines the choice of Cc, the critical dimensionless vortex-loop core parameter, and K0c, the critical "bare" coupling).   * Explain there are 7 pressures that are explored...   * In the basename "vlt_HeatCap_P", "vlt" refers to Vortex Loop Theory (of the superfluid phase transition), "HeatCap" refers to and the molar specific HEAT CAPacity of the system under examination, and "P" refers to the pressure, which must be specified in units of bars in the parameters/inputs below.   * An alternate of this program, using mpfr, is vlt_pHeatCap_P.c.   * This program could be subsumed in vlt_ThermStates.c...   Inputs:   * Dexp    - Why not?   * dl      - step in l, the length scale, which allows derivatives with respect to l   * DK0     - step in K0, the "bare" dimensionless superfluid ratio, which allows derivatives with respect to K0 (corresponds to derivatives wrt temperature)   * Kthresh - (... improve this later: K0c is calculated to be critical within a certain length scale region; as soon as K diverges, you are out of that region and should stop assuming that K0c is truely the critical value of K0. Is this right?)   * You could add options for selecting different sets of temperatures.  Right now, you can just "Decrement temperature (further below Tc)".   * 7 sets of 3-tuples (P,Cc,K0c) from vlt_K0cFind.c and analysis using Ahlers' 1973 data.   * Parameters for Tc(P), rho(T,P), and alpha(T,P).   Output:   * This program returns text file of data in a two dimensional array.*//* EXT FILES: vlt_derk.c *//* COMPILE NOTES:   * To run, type "g++ -lm 3Dvlt_macro_cp_table.c vlt_derk.c" without the quotes.   * NOTE: Be sure that N=3 in vlt_derk.c when compiling.   * WARNING: If you want to record  a0(P)/a0(0),  you have to make sure that K0c0 = K0c(P=0) is set appropriately to its most recent calculated value.*///  Function Preparation  ////=========================================================================//// Standard routine header files //#include <stdio.h>#include <math.h>// Constants and labels //#define IN           // input label#define OUT          // output label#define INOUT        // input/output labelconst double PI    = 3.14159265358979323846;const double PISQ  = 9.86960440108935861883;const double PICU  = 31.00627668029981620634;const double B     = 4.0*PICU/3.0;const double THETA = 0.6;const double R     = 8.31447215;// Program parameters/inputs ////#define Dexp, lmax?const int    N       = 3;const double Kthresh = 5.0;const double DK0     = 5e-7;const double dl      = 0.0001;//const int    lmax    = 100;    // 100 corresponds to largest length scale D = a0*exp(lmax) ~ 6.8e33 meters (huge diameter system)// Parameters for Tc(P):const double Tc0 = 2.17349425585161;const double Tc1 = -0.00982499579394534;const double Tc2 = -0.000118194448444384;const double Tc3 = -4.36914591522034e-07;const double Tc4 = 7.39407378262721e-09;// Parameters for rho(T,P):const double rho00 = 145.145109496329;const double rho10 = -0.0976539693059151;const double rho20 = 0.334163407001684;const double rho30 = -0.446930785976304;const double rho40 = 0.181879478545246;const double rho01 = 1.74477604495583;const double rho11 = -0.0919538993179052;const double rho21 = 0.179844560873926;const double rho31 = -0.133606331352667;const double rho41 = 0.0410225514249919;const double rho02 = -0.0491655379690169;const double rho12 = 0.00710698898070406;const double rho22 = -0.00823054225495917;const double rho32 = 0.000609542602247143;const double rho42 = 0.00114916775392305;const double rho03 = 0.0013415037643754;const double rho13 = -0.000362007479155809;const double rho23 = 0.000358809384119286;const double rho33 = 6.48183954357527e-05;const double rho43 = -0.000104112551302631;const double rho04 = -1.69907294147191e-05;const double rho14 = 5.53820368251513e-06;const double rho24 = -3.15773411117433e-06;const double rho34 = -4.99967306908062e-06;const double rho44 = 3.41331223468399e-06;// Parameters for alpha(T,P):const double alpha00 = -0.00132545289717059;const double alpha10 = 0.0179528212646871;const double alpha20 = -0.077814417132819;const double alpha30 = 0.148812649901035;const double alpha40 = -0.135348183536229;const double alpha50 = 0.0575865394848149;const double alpha60 = -0.00942356361818271;const double alpha01 = 0.00169244447357293;const double alpha11 = -0.021665108348567;const double alpha21 = 0.0875997904161722;const double alpha31 = -0.155075446681196;const double alpha41 = 0.133241381828243;const double alpha51 = -0.0547135426838175;const double alpha61 = 0.00857815766443886;const double alpha02 = -0.000402016588457985;const double alpha12 = 0.00500646576912193;const double alpha22 = -0.0196997735925578;const double alpha32 = 0.0343311248462808;const double alpha42 = -0.0295791060596021;const double alpha52 = 0.0123277022988963;const double alpha62 = -0.00198704719059122;const double alpha03 = 3.50822131497139e-05;const double alpha13 = -0.000417434943625329;const double alpha23 = 0.00157100359153513;const double alpha33 = -0.0026926366274236;const double alpha43 = 0.00238134017220718;const double alpha53 = -0.00104902823471905;const double alpha63 = 0.000181757286633977;const double alpha04 = -1.51074156982117e-06;const double alpha14 = 1.69620331490882e-05;const double alpha24 = -6.10050371264495e-05;const double alpha34 = 0.000107369015843627;const double alpha44 = -0.000106541517748163;const double alpha54 = 5.44104698460238e-05;const double alpha64 = -1.08691954908159e-05;const double alpha05 = 3.11237240810798e-08;const double alpha15 = -3.20093978259846e-07;const double alpha25 = 1.08841581501832e-06;const double alpha35 = -2.12545135194623e-06;const double alpha45 = 2.63498247456092e-06;const double alpha55 = -1.62910668019171e-06;const double alpha65 = 3.71525294733195e-07;const double alpha06 = -2.37222132465804e-10;const double alpha16 = 2.08583118201288e-09;const double alpha26 = -6.5282210389408e-09;const double alpha36 = 1.6933030216303e-08;const double alpha46 = -2.89786898905826e-08;const double alpha56 = 2.12469804642866e-08;const double alpha66 = -5.29362586788296e-09;// Data type definitions //typedef struct {	double l;	double tempv;	double thrmv[N];} STATE;typedef struct {	double arr[N];} RETARRAY;//  Function Prototypes  ////=========================================================================////   derk(func(),calculated,Dl,n)//   vltRecRel(l,z)extern STATE derk(RETARRAY (*func)(double l, double z[]), STATE calculated, double Dl, unsigned n);RETARRAY vltRecRel(double l, double z[]);//  Function Definitions  ////=========================================================================//main(){	// Main function definitions //	int    s,i,j=0;	double P,Cc,K0c;	double Tc,rho,DrhoDT,D2rhoDT2,a0,Da0DT,D2a0DT2,alpha,DalphaDT;	double rho0, a00, K0c0=0.29538951067061;	double K0,U0ok;	double T,Kr;	double DeDK0plus,DeDK0minus,DeDK0,D2eDK02,cp;	double cp01,cp02,cp03,cp04,cp05,cp06,cp07,cp08,cp09,cp10,	       cp11,cp12,cp13,cp14,cp15,cp16,cp17,cp18,cp19,cp20,	       cp21,cp22,cp23;	//double rhos,x,Delok,a;	STATE estimated, plus, minus;	FILE *outfile1,*outfile2;	char *filename1,*filename2;	// Prepare output file 2, print identification, values, and headings for data //	// 2D Wide Tables //	//asprintf(&filename2, "3Dvlt_macro_cp_table_wide_Rho.dat");  // C	//asprintf(&filename2, "3Dvlt_macro_cp_table_wide_Alpha.dat");  // D	//asprintf(&filename2, "3Dvlt_macro_cp_table_wide_AlphaFromRho.dat");  // E	//asprintf(&filename2, "3Dvlt_macro_cp_table_wide_DiffAlphas.dat");  // F	// 1D Long Tables //	//asprintf(&filename2, "3Dvlt_macro_cp_table_long_Rho.dat");  // C	//asprintf(&filename2, "3Dvlt_macro_cp_table_long_Alpha.dat");  // D	//asprintf(&filename2, "3Dvlt_macro_cp_table_long_AlphaFromRho.dat");  // E	asprintf(&filename2, "3Dvlt_macro_cp_table_long_DiffAlphas.dat");  // F	outfile2 = fopen(filename2,"w");	fprintf(outfile2,"# Filename: %s\n", filename2);	fprintf(outfile2,"# Source: 3Dvlt_macro_cp_table.c\n");	fprintf(outfile2,"# Source version: %s\n", "1 (2011 Oct 29 - ...)");	fprintf(outfile2,"# Constant values: PI=%21.21g, PISQ=%21.21g, PICU=%21.21g, B=%21.21g, THETA=%g, R=%g\n", PI,PISQ,PICU,B,THETA,R);	fprintf(outfile2,"# Parameter values: N=%i, Kthresh=%g, DK0=%g, dl=%g\n", N,Kthresh,DK0,dl);	// 2D Wide Table //	//fprintf(outfile2,"# %s\t%s\n", "Temp.","                                 Pressures (atm)                                 ");	//fprintf(outfile2,"# %s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", " (K) "," 0.0"," 2.5"," 5.0"," 7.5","10.0","12.5","15.0","17.5","20.0","22.5","25.0");	// 1D Long Table //	fprintf(outfile2,"# %s\t%s\t%s\n", "T (K)", "P (bar)", "Rho or Alpha etc (kg/m^3 or K^-1 etc)");	// 2D Wide Table //	//for(i=0; i<41; i++){	//	T = 0.10+0.05*i;	//	fprintf(outfile2,"%3.2f\t", T);		// Progress through 7 pressures (and associated values of Cc,K0c), where a data file will be produced for each pressure //		for(s=1; s<=11; s++){			switch(s){ // pressure P in bars				/* using normal settings (in vlt_K0cFind.c, vlt_ThermStates.c, and fits) //				case 1:	P =  0.050;	Cc = 1.10500797392886;	K0c = 0.295614012972922;	break;				case 2:	P =  1.646;	Cc = 1.0581889918361;	K0c = 0.303871530617906;	break;				case 3:	P =  7.328;	Cc = 0.905918431108949;	K0c = 0.335619263473799;	break;				case 4:	P = 15.031;	Cc = 0.730685115724445;	K0c = 0.385639221938482;	break;				case 5:	P = 18.180;	Cc = 0.667831302441093;	K0c = 0.408941994995917;	break;				case 6:	P = 22.533;	Cc = 0.588281338805611;	K0c = 0.44447352661157;		break;				case 7:	P = 25.868;	Cc = 0.532635362503492;	K0c = 0.474695910004971;	break;*/				/* using B' = 2B (in vlt_K0cFind.c, vlt_ThermStates.c, and fits) //				case 1:	P =  0.050;	Cc = 1.1003376541326;	K0c = 0.338730088317275;	break;				case 2:	P =  1.646;	Cc = 1.05648724043934;	K0c = 0.348372781936236;	break;				case 3:	P =  7.328;	Cc = 0.913079877533694;	K0c = 0.385556454984416;	break;				case 4:	P = 15.031;	Cc = 0.746257959253795;	K0c = 0.444486928182064;	break;				case 5:	P = 18.180;	Cc = 0.685924754942954;	K0c = 0.472045003545693;	break;				case 6:	P = 22.533;	Cc = 0.609090754516276;	K0c = 0.51419404658953;		break;				case 7:	P = 25.868;	Cc = 0.554925448693439;	K0c = 0.550204504048639;	break;*/				/* using normal settings (in 3Dvlt_K0cFind.c - Output27, 3Dvlt_macro_noifthen.c,				// and fits from plots_macro/3D_11_Normal_NoIfThen) //				case 1:		P =  0.050;	Cc = 1.10483229772024;	K0c = 0.295643892705827;	break;				case 2:		P =  1.646;	Cc = 1.05802360690523;	K0c = 0.3039017891501;		break;				case 3:		P =  7.328;	Cc = 0.905783785948535;	K0c = 0.335651305449222;	break;				case 4:		P = 15.031;	Cc = 0.730585406559371;	K0c = 0.385673454596625;	break;				case 5:		P = 18.180;	Cc = 0.667741857245225;	K0c = 0.408977828480417;	break;				case 6:		P = 22.533;	Cc = 0.588205298607552;	K0c = 0.444511433704054;	break;				case 7:		P = 25.868;	Cc = 0.532568913867742;	K0c = 0.474735257233818;	break;*/				/* using normal settings (in 3Dvlt_K0cFind.c - Output28, 3Dvlt_macro_noifthen.c,				// and fits from plots_macro/3D_11_Normal_NoIfThen) //				case 1:		P =  0.0*1.01325;	Cc = 1.10632942839817;	K0c = 0.29538951067061;		break;				case 2:		P =  1.0*1.01325;	Cc = 1.07635638256762;	K0c = 0.300595480774154;	break;				case 3:		P =  5.0*1.01325;	Cc = 0.963811435171926;	K0c = 0.322550071407628;	break;				case 4:		P = 10.0*1.01325;	Cc = 0.838186490043836;	K0c = 0.352833451461462;	break;				case 5:		P = 15.0*1.01325;	Cc = 0.727118555504325;	K0c = 0.386868708988648;	break;				case 6:		P = 20.0*1.01325;	Cc = 0.628625944372066;	K0c = 0.425484419386825;	break;				case 7:		P = 24.0*1.01325;	Cc = 0.557881910249367;	K0c = 0.460337048991327;	break;*/				// using normal settings (in 3Dvlt_K0cFind.c - Output29, 3Dvlt_macro_noifthen.c,				// and fits from plots_macro/3D_11_Normal_NoIfThen) //				case 1:		P =  0.0*1.01325;	Cc = 1.10632942839817;	K0c = 0.29538951067061;		break;				case 2:		P =  2.5*1.01325;	Cc = 1.03280678021075;	K0c = 0.308610836254864;	break;				case 3:		P =  5.0*1.01325;	Cc = 0.963811435171926;	K0c = 0.322550071407628;	break;				case 4:		P =  7.5*1.01325;	Cc = 0.899037373713034;	K0c = 0.337267195326344;	break;				case 5:		P = 10.0*1.01325;	Cc = 0.838186490043836;	K0c = 0.352833451461462;	break;				case 6:		P = 12.5*1.01325;	Cc = 0.780969118936599;	K0c = 0.369334358088313;	break;				case 7:		P = 15.0*1.01325;	Cc = 0.727118555504325;	K0c = 0.386868708988648;	break;				case 8:		P = 17.5*1.01325;	Cc = 0.676402747916216;	K0c = 0.405545939114024;	break;				case 9:		P = 20.0*1.01325;	Cc = 0.628625944372066;	K0c = 0.425484419386825;	break;				case 10:	P = 22.5*1.01325;	Cc = 0.583620041108912;	K0c = 0.446813016248088;	break;				case 11:	P = 25.0*1.01325;	Cc = 0.541229882352637;	K0c = 0.469677478874956;	break;			}			Tc  = Tc0 + Tc1*P + Tc2*P*P + Tc3*P*P*P + Tc4*P*P*P*P;			// 1D Long Table //			for(i=0; i<41; i++){				T = 0.10+0.05*i;				estimated.tempv = 1.0-T/Tc;				// Set temperature- and pressure-dependent values //				rho = rho00         + rho10*T         + rho20*T*T         + rho30*T*T*T         + rho40*T*T*T*T 				    + rho01*P       + rho11*T*P       + rho21*T*T*P       + rho31*T*T*T*P       + rho41*T*T*T*T*P 				    + rho02*P*P     + rho12*T*P*P     + rho22*T*T*P*P     + rho32*T*T*T*P*P     + rho42*T*T*T*T*P*P 				    + rho03*P*P*P   + rho13*T*P*P*P   + rho23*T*T*P*P*P   + rho33*T*T*T*P*P*P   + rho43*T*T*T*T*P*P*P 				    + rho04*P*P*P*P + rho14*T*P*P*P*P + rho24*T*T*P*P*P*P + rho34*T*T*T*P*P*P*P + rho44*T*T*T*T*P*P*P*P;				DrhoDT = rho10         + 2.0*rho20*T         + 3.0*rho30*T*T         + 4.0*rho40*T*T*T 				       + rho11*P       + 2.0*rho21*T*P       + 3.0*rho31*T*T*P       + 4.0*rho41*T*T*T*P 				       + rho12*P*P     + 2.0*rho22*T*P*P     + 3.0*rho32*T*T*P*P     + 4.0*rho42*T*T*T*P*P 				       + rho13*P*P*P   + 2.0*rho23*T*P*P*P   + 3.0*rho33*T*T*P*P*P   + 4.0*rho43*T*T*T*P*P*P 				       + rho14*P*P*P*P + 2.0*rho24*T*P*P*P*P + 3.0*rho34*T*T*P*P*P*P + 4.0*rho44*T*T*T*P*P*P*P;				D2rhoDT2 = 2.0*rho20         + 6.0*rho30*T         + 12.0*rho40*T*T 				         + 2.0*rho21*P       + 6.0*rho31*T*P       + 12.0*rho41*T*T*P 				         + 2.0*rho22*P*P     + 6.0*rho32*T*P*P     + 12.0*rho42*T*T*P*P 				         + 2.0*rho23*P*P*P   + 6.0*rho33*T*P*P*P   + 12.0*rho43*T*T*P*P*P 				         + 2.0*rho24*P*P*P*P + 6.0*rho34*T*P*P*P*P + 12.0*rho44*T*T*P*P*P*P;				a0 = 549.0*Tc*K0c/rho;  // in angstroms				// a0(T,P) = ( m^2 kB Tc(P) K0c(P) ) / (hbar^2 rho(T,P) )				// where m = 6.65e-27 is the mass of 4He atom in kg, kB is the Boltzmann constant, and hbar is the Dirac constant				Da0DT = -549.0*Tc*K0c*DrhoDT/(rho*rho);				D2a0DT2 = 2.0*549.0*Tc*K0c*DrhoDT*DrhoDT/(rho*rho*rho) - 549.0*Tc*K0c*D2rhoDT2/(rho*rho);				// At P=0: //				rho0 = rho00 + rho10*T + rho20*T*T + rho30*T*T*T + rho40*T*T*T*T;				a00  = 549.0*Tc0*K0c0/rho0;  // in angstroms				alpha = alpha00             + alpha10*T             + alpha20*T*T             + alpha30*T*T*T             + alpha40*T*T*T*T             + alpha50*T*T*T*T*T             + alpha60*T*T*T*T*T*T 				      + alpha01*P           + alpha11*T*P           + alpha21*T*T*P           + alpha31*T*T*T*P           + alpha41*T*T*T*T*P           + alpha51*T*T*T*T*T*P           + alpha61*T*T*T*T*T*T*P 				      + alpha02*P*P         + alpha12*T*P*P         + alpha22*T*T*P*P         + alpha32*T*T*T*P*P         + alpha42*T*T*T*T*P*P         + alpha52*T*T*T*T*T*P*P         + alpha62*T*T*T*T*T*T*P*P 				      + alpha03*P*P*P       + alpha13*T*P*P*P       + alpha23*T*T*P*P*P       + alpha33*T*T*T*P*P*P       + alpha43*T*T*T*T*P*P*P       + alpha53*T*T*T*T*T*P*P*P       + alpha63*T*T*T*T*T*T*P*P*P 				      + alpha04*P*P*P*P     + alpha14*T*P*P*P*P     + alpha24*T*T*P*P*P*P     + alpha34*T*T*T*P*P*P*P     + alpha44*T*T*T*T*P*P*P*P     + alpha54*T*T*T*T*T*P*P*P*P     + alpha64*T*T*T*T*T*T*P*P*P*P 				      + alpha05*P*P*P*P*P   + alpha15*T*P*P*P*P*P   + alpha25*T*T*P*P*P*P*P   + alpha35*T*T*T*P*P*P*P*P   + alpha45*T*T*T*T*P*P*P*P*P   + alpha55*T*T*T*T*T*P*P*P*P*P   + alpha65*T*T*T*T*T*T*P*P*P*P*P 				      + alpha06*P*P*P*P*P*P + alpha16*T*P*P*P*P*P*P + alpha26*T*T*P*P*P*P*P*P + alpha36*T*T*T*P*P*P*P*P*P + alpha46*T*T*T*T*P*P*P*P*P*P + alpha56*T*T*T*T*T*P*P*P*P*P*P + alpha66*T*T*T*T*T*T*P*P*P*P*P*P;				DalphaDT = alpha10             + 2.0*alpha20*T             + 3.0*alpha30*T*T             + 4.0*alpha40*T*T*T             + 5.0*alpha50*T*T*T*T             + 6.0*alpha60*T*T*T*T*T 				         + alpha11*P           + 2.0*alpha21*T*P           + 3.0*alpha31*T*T*P           + 4.0*alpha41*T*T*T*P           + 5.0*alpha51*T*T*T*T*P           + 6.0*alpha61*T*T*T*T*T*P 				         + alpha12*P*P         + 2.0*alpha22*T*P*P         + 3.0*alpha32*T*T*P*P         + 4.0*alpha42*T*T*T*P*P         + 5.0*alpha52*T*T*T*T*P*P         + 6.0*alpha62*T*T*T*T*T*P*P 				         + alpha13*P*P*P       + 2.0*alpha23*T*P*P*P       + 3.0*alpha33*T*T*P*P*P       + 4.0*alpha43*T*T*T*P*P*P       + 5.0*alpha53*T*T*T*T*P*P*P       + 6.0*alpha63*T*T*T*T*T*P*P*P 				         + alpha14*P*P*P*P     + 2.0*alpha24*T*P*P*P*P     + 3.0*alpha34*T*T*P*P*P*P     + 4.0*alpha44*T*T*T*P*P*P*P     + 5.0*alpha54*T*T*T*T*P*P*P*P     + 6.0*alpha64*T*T*T*T*T*P*P*P*P 				         + alpha15*P*P*P*P*P   + 2.0*alpha25*T*P*P*P*P*P   + 3.0*alpha35*T*T*P*P*P*P*P   + 4.0*alpha45*T*T*T*P*P*P*P*P   + 5.0*alpha55*T*T*T*T*P*P*P*P*P   + 6.0*alpha65*T*T*T*T*T*P*P*P*P*P 				         + alpha16*P*P*P*P*P*P + 2.0*alpha26*T*P*P*P*P*P*P + 3.0*alpha36*T*T*P*P*P*P*P*P + 4.0*alpha46*T*T*T*P*P*P*P*P*P + 5.0*alpha56*T*T*T*T*P*P*P*P*P*P + 6.0*alpha66*T*T*T*T*T*P*P*P*P*P*P;				// Initialize lengthscale, energy values, and in/decrements at zero //				estimated.l = 0.0;				plus.l      = 0.0;				minus.l     = 0.0;				estimated.thrmv[2] = 0.0;				plus.thrmv[2]      = 0.0;				minus.thrmv[2]     = 0.0;				// Initialize temperature-dependent values at initial lengthscale //				K0 = K0c/(1.0-estimated.tempv);				estimated.thrmv[0] = K0;				plus.thrmv[0]      = K0+DK0;				minus.thrmv[0]     = K0-DK0;				estimated.thrmv[1] = exp(-PISQ*K0*Cc);				plus.thrmv[1]      = exp(-(K0+DK0)*PISQ*Cc);				minus.thrmv[1]     = exp(-(K0-DK0)*PISQ*Cc);				// Additional Bare Value: (smallest loop energy ~ roton energy)/kB //				U0ok = PISQ*K0c*Cc*Tc;				// 2D Wide Table //				//fprintf(outfile2,"%17.16g\t", rho);  // C				//fprintf(outfile2,"%17.16g\t", alpha);  // D				//fprintf(outfile2,"%17.16g\t", (1.0/rho)*DrhoDT);  // E				//fprintf(outfile2,"%17.16g\t", alpha-(1.0/rho)*DrhoDT);  //  F				// C: calculate rho using fit, put in table				// D: calculate alpha using fit, put in table				// E: calculate alpha using rho, put in table				// F: calculate alpha1-alpha2, put in table				// 1D Long Table //				//fprintf(outfile2,"%3.2f\t%4.3f\t%17.16g\n", T, P, rho);  // C				//fprintf(outfile2,"%3.2f\t%4.3f\t%17.16g\n", T, P, alpha);  // D				//fprintf(outfile2,"%3.2f\t%4.3f\t%17.16g\n", T, P, (1.0/rho)*DrhoDT);  // E				fprintf(outfile2,"%3.2f\t%4.3f\t%17.16g\n", T, P, alpha-(1.0/rho)*DrhoDT);  // F			}		// 1D Long Table //		}	// 2D Wide Table //	//	fprintf(outfile2,"\n");	//}	fclose(outfile2);}// vortex loop theory recursion relations //RETARRAY vltRecRel(double l, double z[]){	RETARRAY dzdl;	dzdl.arr[0] = z[0]-B*z[0]*z[0]*z[1];	dzdl.arr[1] = z[1]*( 6.0 - PISQ*z[0]*(1.0-THETA*log(z[0])) );	dzdl.arr[2] = -PI*z[1]*exp(-3.0*l);	return dzdl;}//  Program Notes  ////=========================================================================///*See further documentation (UCLAresearchNotes.pdf, UCLAresearchPrograms.pdf, derk1.c) for elaboration.plus and minus are test states (with test state-variables)*/