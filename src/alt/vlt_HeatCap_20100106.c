/*  File Comments  *//*=========================================================================*//* filename: vlt_HeatCap_P.c *//* description: This C program calculates the molar specific heat capacity c_V of a system of liquid helium-4 at different temperatures, pressures, and length scales.       The filename vlt_HeatCap.c refers to the "vortex loop theory" (vlt) of the superfluid phase transition and the molar specific "heat capacity" (HeatCap) of the system under examination. *//* ext files: derk1.c *//* author: Andrew Forrester <aforrester@ucla.edu> */// NOTE: Be sure that N=3 in derk1.c when compiling.// NOTE: Update P, Cc, K0c, and the output filename before running. /*  Function Preparation  *//*=========================================================================*/#include <stdio.h>#include <math.h>#define IN#define OUT#define INOUT#define PI     3.14159265358979323846#define PISQ   9.86960440108935861883#define A      4.0*PI*PI*PI/3.0#define DK0    1e-07#define P      0.050  // pressure in bars#define Cc     1.107411553625760#define K0c    0.2952060040779711#define N      3/*P	Cc	K0c0.050	1.107411553625760	0.29520600407797111.646	1.060208920765020	0.3035026106143797.328	0.906690064087517	0.33543579109605715.031	0.730451367152917	0.38571948629805218.180	0.667516675997090	0.40906807701379122.533	0.588081513758998	0.44457316028702425.868	0.532586148563099	0.474725050976230*//*// Parameters for Cc(P):#define Cc0    1.10892106122653#define Cc1   -0.0302090756207303#define Cc2    0.000378628147396303#define Cc3   -3.12142606957213e-06#define Cc4    1.29173646324374e-08// Parameters for K0c(P):#define K0c0   0.295581776856052#define K0c1   0.00411480553845432#define K0c2   0.000209636865638176#define K0c3  -6.16658606260075e-06#define K0c4   9.20280978255458e-08*/// Parameters for Tc(P):#define Tc0    2.173494256#define Tc1   -0.009824996#define Tc2   -0.000118194#define Tc3   -0.000000437#define Tc4    0.000000007// Parameters for rho(T,P):#define R00    145.145109496329000#define R10   -0.097653969305915#define R20    0.334163407001684#define R30   -0.446930785976304#define R40    0.181879478545246#define R01    1.744776044955830#define R11   -0.091953899317905#define R21    0.179844560873926#define R31   -0.133606331352667#define R41    0.041022551424992#define R02   -0.049165537969017#define R12    0.007106988980704#define R22   -0.008230542254959#define R32    0.000609542602247#define R42    0.001149167753923#define R03    0.001341503764375#define R13   -0.000362007479156#define R23    0.000358809384119#define R33    0.000064818395436#define R43   -0.000104112551303#define R04   -0.000016990729415#define R14    0.000005538203683#define R24   -0.000003157734111#define R34   -0.000004999673069#define R44    0.000003413312235typedef struct {	double l;	double tempv;	double thrmv[N];} STATE;typedef struct {	double arr[N];} RETARRAY;/*  Function Prototypes  *//*=========================================================================*///   derk(func(),calculated,Dl,n)//   ringrecrel(l,z)extern STATE derk(RETARRAY (*func)(double l, double z[]), STATE calculated, double Dl, unsigned n);RETARRAY ringrecrel(double l, double z[]);/*  Function Definitions  *//*=========================================================================*/main(){	int i,j=0;	double Tc,T,rho,a0,K0,Kr,derivplus,derivminus,cap;	//double Cc,K0c,T,rho,rhos,x,Delok,a;	STATE estimated, plus, minus;	FILE *outfile;	/* Set pressure dependence with the critical values of C and K0 */	// Cc  = Cc0  + Cc1*P  + Cc2*P*P  + Cc3*P*P*P  + Cc4*P*P*P*P;	// K0c = K0c0 + K0c1*P + K0c2*P*P + K0c3*P*P*P + K0c4*P*P*P*P;	/* Print headings for data to screen and output file */	outfile = fopen("vlt_HeatCap_P_00.050bar_DK0_1e-07_adjust.dat","w");  //  "vlt_HeatCap_P.out"	fprintf(outfile,"%s\t%s\t%s\t%s\t%s\t\n", "tempv","cap","l","Kr/K0","F");	printf(         "%s\t%s\t%s\t%s\t%s\t\n", "tempv","cap","l","Kr/K0","F");	/* Loop through different temperatures (calculations for each temp are independent)? */	for(i=0; i<35; i++){		/* Decrement temperature (further below Tc) */		estimated.tempv = (1.0e-8)*exp(0.4*i);		/* Set temperature- and pressure-dependent values */		Tc = Tc0 + Tc1*P + Tc2*P*P + Tc3*P*P*P + Tc4*P*P*P*P;		T = Tc*(1-estimated.tempv);		rho = R00 +R10*T+R20*T*T+R30*T*T*T+R40*T*T*T*T +R01*P+R11*T*P+R21*T*T*P+R31*T*T*T*P+R41*T*T*T*T*P +R02*P*P+R12*T*P*P+R22*T*T*P*P+R32*T*T*T*P*P+R42*T*T*T*T*P*P +R03*P*P*P+R13*T*P*P*P+R23*T*T*P*P*P+R33*T*T*T*P*P*P+R43*T*T*T*T*P*P*P +R04*P*P*P*P+R14*T*P*P*P*P+R24*T*T*P*P*P*P+R34*T*T*T*P*P*P*P+R44*T*T*T*T*P*P*P*P;		a0 = 549*Tc*K0c/rho;  // in angstroms		// a0(T,P) = ( m^2 kB Tc(P) K0c(P) ) / (hbar^2 Rho(T,P) )		// where m = 6.65e-27 is the mass of 4He atom in kg, kB is the Boltzmann constant, and hbar is the Dirac constant		/* Initialize lengthscale and energy values, zero in/decrements */		estimated.l = 0.0;		plus.l      = 0.0;		minus.l     = 0.0;		estimated.thrmv[2] = 0.0;		plus.thrmv[2]      = 0.0;		minus.thrmv[2]     = 0.0;		/* Initialize temperature-dependent values at initial lengthscale */		K0 = K0c/(1.0-estimated.tempv);		Kr = K0;		estimated.thrmv[0] = K0;		plus.thrmv[0]      = K0+DK0;		minus.thrmv[0]     = K0-DK0;		estimated.thrmv[1] = exp(-PISQ*K0*Cc);		plus.thrmv[1]      = exp(-(K0+DK0)*PISQ*Cc);		minus.thrmv[1]     = exp(-(K0-DK0)*PISQ*Cc);		/*  */		while(estimated.thrmv[0]<6){			estimated = derk(IN ringrecrel, INOUT estimated, IN 0.0001, IN N);			plus      = derk(IN ringrecrel, INOUT plus,      IN 0.0001, IN N);			minus     = derk(IN ringrecrel, INOUT minus,     IN 0.0001, IN N);			Kr = estimated.thrmv[0]*exp(-estimated.l);			derivplus = (plus.thrmv[2]-estimated.thrmv[2])/DK0;			derivminus = (estimated.thrmv[2]-minus.thrmv[2])/DK0;			// cap = -8.31*(146/rho)*K0*K0*(derivplus-derivminus)/DK0;			cap = -8.31447215*((6.65e3)/(rho*a0*a0*a0))*K0*K0*(derivplus-derivminus)/DK0;			j = j+1;			/*if(j%2000==0)				printf("%G %g %g %g \n%1.18e\n",t,Kr/K0,y[0],y[1],cap);			if(j>10000)				j=0;*/		}		/*  */		cap = -8.31447215*((6.65e3)/(rho*a0*a0*a0))*K0*K0*(derivplus-derivminus)/DK0;		// cap = -8.31*(m/rho)*K0*K0*(derivplus-derivminus)/DK0;		/*  */		fprintf(outfile,"%g\t%g\t%g\t%g\t%g\n",			estimated.tempv, cap, estimated.l, Kr/K0, estimated.thrmv[2]);		fflush(outfile);		printf(         "%g\t%g\t%g\t%g\t%g\n",			estimated.tempv, cap, estimated.l, Kr/K0, estimated.thrmv[2]);	}	fclose(outfile);}// vortex "ring" recursion relationsRETARRAY ringrecrel(double l, double z[]){	RETARRAY dzdl;	dzdl.arr[0] = z[0]-A*z[1]*z[0]*z[0];	dzdl.arr[1] = z[1]*(6.0-PISQ*z[0]*(1.0-0.6*log(z[0])));	dzdl.arr[2] = -PI*z[1]*exp(-3.0*l);	return dzdl;}// deriv = de/dK0