//  File Comments  ////=========================================================================///* FILENAME: 3Dvlt_macro_cp.c *//* VERSION: 7 (2011 Oct 20 - ...)            More terms have been added, due to the refined derivation of cp.            New name: from vlt_HeatCap_P.c to 3Dvlt_macro_cp.c            C is now out of the recursion relations, normal settings *//* AUTHOR: Andrew Forrester <aforrester@ucla.edu> *//* DESCRIPTION:   * This C program calculates the (length-scale-dependent) molar specific heat capacity at constant pressure c_P (cp) (and other thermodynamic quantities) of a system of liquid helium-4 (4He) at various temperatures and length scales, given a pressure (in the parameters/inputs below).   * The system is a spherical region (of variable diameter greater than D) of liquid 4He at some constant pressure, near or below the critical transition temperature Tc (which depends on pressure) separating normal fluid and superfluid (aka the lambda temperature).   * The program uses the vortex-loop theory of the superfluid phase transition (i.e., its differential recursion relations) of Gary A. Williams and Subodh R. Shenoy and a 4th-order Runge-Kutta integration method to calculate (length-scale-dependent) thermodynamic quantities (especially cp) of the system at a set of temperatures {Tn}, at various length scales (no greater than a length scale corresponding to the the limit K<Kthresh), and at some pressure (which also determines the choice of Cc, the critical dimensionless vortex-loop-core energy, and K0c, the critical "bare" dimensionless superfluid ratio).   * Explain there are 7 pressures that are explored...   * In the basename "vlt_HeatCap_P", "vlt" refers to Vortex Loop Theory (of the superfluid phase transition), "HeatCap" refers to and the molar specific HEAT CAPacity of the system under examination, and "P" refers to the pressure, which must be specified in units of bars in the parameters/inputs below.   * An alternate of this program, using mpfr, is vlt_pHeatCap_P.c.   * This program could be subsumed in vlt_ThermStates.c...   Inputs:   * Dexp    - Why not?   * dl      - step in l, the length scale, which allows derivatives with respect to l   * DK0     - step in K0, the "bare" dimensionless superfluid ratio, which allows derivatives with respect to K0 (corresponds to derivatives wrt temperature)   * Kthresh - (... improve this later: K0c is calculated to be critical within a certain length scale region; as soon as K diverges, you are out of that region and should stop assuming that K0c is truely the critical value of K0. Is this right?)   * You could add options for selecting different sets of temperatures.  Right now, you can just "Decrement temperature (further below Tc)".   * 7 sets of 3-tuples (P,Cc,K0c) from vlt_K0cFind.c and analysis using Ahlers' 1973 data.   * Parameters for Tc(P), rho(T,P), and alpha(T,P).   Output:   * This program returns text file of data in a two dimensional array.*//* EXT FILES: vlt_derk.c *//* COMPILE NOTES:   * To run, type "gcc -lm vlt_HeatCap_P.c vlt_derk.c" without the quotes.   * NOTE: Be sure that N=3 in vlt_derk.c when compiling.   * NOTE: Update P, Cc, K0c, and the output filename before running.*///  Function Preparation  ////=========================================================================//// Standard routine header files //#include <stdio.h>#include <math.h>// Constants and labels //#define IN           // input label#define OUT          // output label#define INOUT        // input/output labelconst double PI    = 3.14159265358979323846;const double PISQ  = 9.86960440108935861883;const double PICU  = 31.00627668029981620634;const double B     = 4.0*PICU/3.0;const double THETA = 0.6;const double R     = 8.31447215;// Program parameters/inputs ////#define Dexp, lmax?const int    N        = 3;//const double lmax     = 100.0;   //  (not used since we continue calculations until K>Kthresh)  1  //  maximum of the length scale l (potentially approximate)const int    lsteps   = 100000;    //  1250, 5000, 100000 //  lsteps = lmax/dl = 10/0.0001 = 100,000  (make sure this is divisible by ldatamax)const int    lpts     = lsteps+1;  //  from l=0 to l=lmax, inclusive (incl. the boundary-condition-enforcing pnt, there are lpts+1 "l" pnts)const int    ldatamax = 10;        //  (for bug check in this program)50,100 //  max number of data points recorded per temperature examinedconst double Kthresh  = 5.0;const double DK0      = 5e-7;const double dl       = 0.0001;//const int    lmax    = 100;    // 100 corresponds to largest length scale D = a0*exp(lmax) ~ 6.8e33 meters (huge diameter system)// Parameters for Tc(P):const double Tc0 =  2.173494256;const double Tc1 = -0.009824996;const double Tc2 = -0.000118194;const double Tc3 = -0.000000437;const double Tc4 =  0.000000007;// Parameters for rho(T,P):const double rho00 =  145.145109496329000;const double rho10 = -0.097653969305915;const double rho20 =  0.334163407001684;const double rho30 = -0.446930785976304;const double rho40 =  0.181879478545246;const double rho01 =  1.744776044955830;const double rho11 = -0.091953899317905;const double rho21 =  0.179844560873926;const double rho31 = -0.133606331352667;const double rho41 =  0.041022551424992;const double rho02 = -0.049165537969017;const double rho12 =  0.007106988980704;const double rho22 = -0.008230542254959;const double rho32 =  0.000609542602247;const double rho42 =  0.001149167753923;const double rho03 =  0.001341503764375;const double rho13 = -0.000362007479156;const double rho23 =  0.000358809384119;const double rho33 =  0.000064818395436;const double rho43 = -0.000104112551303;const double rho04 = -0.000016990729415;const double rho14 =  0.000005538203683;const double rho24 = -0.000003157734111;const double rho34 = -0.000004999673069;const double rho44 =  0.000003413312235;// Parameters for alpha(T,P):const double alpha00 = -0.00132545289717059;const double alpha10 = 0.0179528212646871;const double alpha20 = -0.077814417132819;const double alpha30 = 0.148812649901035;const double alpha40 = -0.135348183536229;const double alpha50 = 0.0575865394848149;const double alpha60 = -0.00942356361818271;const double alpha01 = 0.00169244447357293;const double alpha11 = -0.021665108348567;const double alpha21 = 0.0875997904161722;const double alpha31 = -0.155075446681196;const double alpha41 = 0.133241381828243;const double alpha51 = -0.0547135426838175;const double alpha61 = 0.00857815766443886;const double alpha02 = -0.000402016588457985;const double alpha12 = 0.00500646576912193;const double alpha22 = -0.0196997735925578;const double alpha32 = 0.0343311248462808;const double alpha42 = -0.0295791060596021;const double alpha52 = 0.0123277022988963;const double alpha62 = -0.00198704719059122;const double alpha03 = 3.50822131497139e-05;const double alpha13 = -0.000417434943625329;const double alpha23 = 0.00157100359153513;const double alpha33 = -0.0026926366274236;const double alpha43 = 0.00238134017220718;const double alpha53 = -0.00104902823471905;const double alpha63 = 0.000181757286633977;const double alpha04 = -1.51074156982117e-06;const double alpha14 = 1.69620331490882e-05;const double alpha24 = -6.10050371264495e-05;const double alpha34 = 0.000107369015843627;const double alpha44 = -0.000106541517748163;const double alpha54 = 5.44104698460238e-05;const double alpha64 = -1.08691954908159e-05;const double alpha05 = 3.11237240810798e-08;const double alpha15 = -3.20093978259846e-07;const double alpha25 = 1.08841581501832e-06;const double alpha35 = -2.12545135194623e-06;const double alpha45 = 2.63498247456092e-06;const double alpha55 = -1.62910668019171e-06;const double alpha65 = 3.71525294733195e-07;const double alpha06 = -2.37222132465804e-10;const double alpha16 = 2.08583118201288e-09;const double alpha26 = -6.5282210389408e-09;const double alpha36 = 1.6933030216303e-08;const double alpha46 = -2.89786898905826e-08;const double alpha56 = 2.12469804642866e-08;const double alpha66 = -5.29362586788296e-09;//  Function Prototypes  ////=========================================================================//// rk4((*f)(),*x,y[],h,n);// EqRecRel(x,z,dzdx,n);void rk4(void (*f)(double, double*, double*, unsigned int), double *x, double y[], double h, unsigned n);void EqRecRel(double x, double z[], double dzdx[], unsigned n);//  Function Definitions  ////=========================================================================//main(){	// Main function definitions //	int s,i,j=0;	double P,Cc,K0c;		double K0,Kr,Tc,T,rho,DrhoDT,D2rhoDT2,a0,Da0DT,D2a0DT2;	double DeDK0plus,DeDK0minus,DeDK0,D2eDK02,alpha,DalphaDT,cp;	double cp01,cp02,cp03,cp04,cp05,cp06,cp07,cp08,cp09,cp10;	//double rhos,x,Delok,a;	STATE estimated, plus, minus;	FILE *outfile;	char *filename;	double dblsteps=lsteps, dl=lmax/dblsteps;	double x, l[lpts];	double Tfrac, tempv;	double z[N], K[lpts], G[lpts], e[lpts];	double K0, y0;	double Kr[lpts], Cc, K0c;	// Progress through 7 pressures (and associated values of Cc,K0c), where a data file will be produced for each pressure //	for(s=1; s<=7; s++){		switch(s){ // pressure P in bars			// using normal settings (in vlt_K0cFind.c, vlt_ThermStates.c, and fits) //			case 1:	P =  0.050;	Cc = 1.10500797392886;	K0c = 0.295614012972922;	break;			case 2:	P =  1.646;	Cc = 1.0581889918361;	K0c = 0.303871530617906;	break;			case 3:	P =  7.328;	Cc = 0.905918431108949;	K0c = 0.335619263473799;	break;			case 4:	P = 15.031;	Cc = 0.730685115724445;	K0c = 0.385639221938482;	break;			case 5:	P = 18.180;	Cc = 0.667831302441093;	K0c = 0.408941994995917;	break;			case 6:	P = 22.533;	Cc = 0.588281338805611;	K0c = 0.44447352661157;		break;			case 7:	P = 25.868;	Cc = 0.532635362503492;	K0c = 0.474695910004971;	break;			/* using B' = 2B (in vlt_K0cFind.c, vlt_ThermStates.c, and fits) //			case 1:	P =  0.050;	Cc = 1.1003376541326;	K0c = 0.338730088317275;	break;			case 2:	P =  1.646;	Cc = 1.05648724043934;	K0c = 0.348372781936236;	break;			case 3:	P =  7.328;	Cc = 0.913079877533694;	K0c = 0.385556454984416;	break;			case 4:	P = 15.031;	Cc = 0.746257959253795;	K0c = 0.444486928182064;	break;			case 5:	P = 18.180;	Cc = 0.685924754942954;	K0c = 0.472045003545693;	break;			case 6:	P = 22.533;	Cc = 0.609090754516276;	K0c = 0.51419404658953;		break;			case 7:	P = 25.868;	Cc = 0.554925448693439;	K0c = 0.550204504048639;	break; */		}		// Prepare output file, print identification, values, and headings for data (to screen, too) //		asprintf(&filename, "3Dvlt_macro_cp_P%06.3f_DK0%1.0e_i47_WithoutSTATE.dat", P, DK0);  //i47 means 47 temperature data points (see i<47 below)		outfile = fopen(filename,"w");  //  E.g., "vlt_HeatCap_P.out" or "vlt_HeatCap_P_00.050_DK0_1e-07.dat"		fprintf(outfile,"# Filename: %s\n", filename);		fprintf(outfile,"# Source: 3Dvlt_macro_cp.c\n");		fprintf(outfile,"# Source version: %s\n", "7 (2011 Oct 20 - ...)");		fprintf(outfile,"# Constant values: PI=%21.21g, PISQ=%21.21g, PICU=%21.21g, B=%21.21g, THETA=%g, R=%g\n", PI,PISQ,PICU,B,THETA,R);		fprintf(outfile,"# Parameter values: N=%i, Kthresh=%g, DK0=%g, dl=%g\n", N,Kthresh,DK0,dl);		fprintf(outfile,"%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "T/Tc","1-T/Tc","l","K","y","e","Kr","Kr/K0","cp");		printf(         "\n%s%g\t%s%g\t%s%g%s\n\n", " ---  P = ",P,"Cc = ",Cc,"K0c = ",K0c,"  ---");		printf(         "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", "T/Tc","1-T/Tc","l","K","y","e","Kr","Kr/K0","cp");		// Loop through different temperatures (calculations for each temp are independent) //		//for(i=0; i<35; i++){		for(i=0; i<47; i++){			// Decrement temperature (further below Tc) //			estimated.tempv = (1.0e-8)*exp(0.4*i);			// Set temperature- and pressure-dependent values //			Tc = Tc0 + Tc1*P + Tc2*P*P + Tc3*P*P*P + Tc4*P*P*P*P;			T = Tc*(1-estimated.tempv);			rho = rho00         + rho10*T         + rho20*T*T         + rho30*T*T*T         + rho40*T*T*T*T 			    + rho01*P       + rho11*T*P       + rho21*T*T*P       + rho31*T*T*T*P       + rho41*T*T*T*T*P 			    + rho02*P*P     + rho12*T*P*P     + rho22*T*T*P*P     + rho32*T*T*T*P*P     + rho42*T*T*T*T*P*P 			    + rho03*P*P*P   + rho13*T*P*P*P   + rho23*T*T*P*P*P   + rho33*T*T*T*P*P*P   + rho43*T*T*T*T*P*P*P 			    + rho04*P*P*P*P + rho14*T*P*P*P*P + rho24*T*T*P*P*P*P + rho34*T*T*T*P*P*P*P + rho44*T*T*T*T*P*P*P*P;			DrhoDT = rho10         + 2.0*rho20*T         + 3.0*rho30*T*T         + 4.0*rho40*T*T*T 			       + rho11*P       + 2.0*rho21*T*P       + 3.0*rho31*T*T*P       + 4.0*rho41*T*T*T*P 			       + rho12*P*P     + 2.0*rho22*T*P*P     + 3.0*rho32*T*T*P*P     + 4.0*rho42*T*T*T*P*P 			       + rho13*P*P*P   + 2.0*rho23*T*P*P*P   + 3.0*rho33*T*T*P*P*P   + 4.0*rho43*T*T*T*P*P*P 			       + rho14*P*P*P*P + 2.0*rho24*T*P*P*P*P + 3.0*rho34*T*T*P*P*P*P + 4.0*rho44*T*T*T*P*P*P*P;			D2rhoDT2 = 2.0*rho20         + 6.0*rho30*T         + 12.0*rho40*T*T 			         + 2.0*rho21*P       + 6.0*rho31*T*P       + 12.0*rho41*T*T*P 			         + 2.0*rho22*P*P     + 6.0*rho32*T*P*P     + 12.0*rho42*T*T*P*P 			         + 2.0*rho23*P*P*P   + 6.0*rho33*T*P*P*P   + 12.0*rho43*T*T*P*P*P 			         + 2.0*rho24*P*P*P*P + 6.0*rho34*T*P*P*P*P + 12.0*rho44*T*T*P*P*P*P;			a0 = 549.0*Tc*K0c/rho;  // in angstroms			// a0(T,P) = ( m^2 kB Tc(P) K0c(P) ) / (hbar^2 rho(T,P) )			// where m = 6.65e-27 is the mass of 4He atom in kg, kB is the Boltzmann constant, and hbar is the Dirac constant			Da0DT = -549.0*Tc*K0c*DrhoDT/(rho*rho);			D2a0DT2 = 2.0*549.0*Tc*K0c*DrhoDT*DrhoDT/(rho*rho*rho) - 549.0*Tc*K0c*D2rhoDT2/(rho*rho);			alpha = alpha00             + alpha10*T             + alpha20*T*T             + alpha30*T*T*T             + alpha40*T*T*T*T             + alpha50*T*T*T*T*T             + alpha60*T*T*T*T*T*T 			      + alpha01*P           + alpha11*T*P           + alpha21*T*T*P           + alpha31*T*T*T*P           + alpha41*T*T*T*T*P           + alpha51*T*T*T*T*T*P           + alpha61*T*T*T*T*T*T*P 			      + alpha02*P*P         + alpha12*T*P*P         + alpha22*T*T*P*P         + alpha32*T*T*T*P*P         + alpha42*T*T*T*T*P*P         + alpha52*T*T*T*T*T*P*P         + alpha62*T*T*T*T*T*T*P*P 			      + alpha03*P*P*P       + alpha13*T*P*P*P       + alpha23*T*T*P*P*P       + alpha33*T*T*T*P*P*P       + alpha43*T*T*T*T*P*P*P       + alpha53*T*T*T*T*T*P*P*P       + alpha63*T*T*T*T*T*T*P*P*P 			      + alpha04*P*P*P*P     + alpha14*T*P*P*P*P     + alpha24*T*T*P*P*P*P     + alpha34*T*T*T*P*P*P*P     + alpha44*T*T*T*T*P*P*P*P     + alpha54*T*T*T*T*T*P*P*P*P     + alpha64*T*T*T*T*T*T*P*P*P*P 			      + alpha05*P*P*P*P*P   + alpha15*T*P*P*P*P*P   + alpha25*T*T*P*P*P*P*P   + alpha35*T*T*T*P*P*P*P*P   + alpha45*T*T*T*T*P*P*P*P*P   + alpha55*T*T*T*T*T*P*P*P*P*P   + alpha65*T*T*T*T*T*T*P*P*P*P*P 			      + alpha06*P*P*P*P*P*P + alpha16*T*P*P*P*P*P*P + alpha26*T*T*P*P*P*P*P*P + alpha36*T*T*T*P*P*P*P*P*P + alpha46*T*T*T*T*P*P*P*P*P*P + alpha56*T*T*T*T*T*P*P*P*P*P*P + alpha66*T*T*T*T*T*T*P*P*P*P*P*P;			DalphaDT = alpha10             + 2.0*alpha20*T             + 3.0*alpha30*T*T             + 4.0*alpha40*T*T*T             + 5.0*alpha50*T*T*T*T             + 6.0*alpha60*T*T*T*T*T 			         + alpha11*P           + 2.0*alpha21*T*P           + 3.0*alpha31*T*T*P           + 4.0*alpha41*T*T*T*P           + 5.0*alpha51*T*T*T*T*P           + 6.0*alpha61*T*T*T*T*T*P 			         + alpha12*P*P         + 2.0*alpha22*T*P*P         + 3.0*alpha32*T*T*P*P         + 4.0*alpha42*T*T*T*P*P         + 5.0*alpha52*T*T*T*T*P*P         + 6.0*alpha62*T*T*T*T*T*P*P 			         + alpha13*P*P*P       + 2.0*alpha23*T*P*P*P       + 3.0*alpha33*T*T*P*P*P       + 4.0*alpha43*T*T*T*P*P*P       + 5.0*alpha53*T*T*T*T*P*P*P       + 6.0*alpha63*T*T*T*T*T*P*P*P 			         + alpha14*P*P*P*P     + 2.0*alpha24*T*P*P*P*P     + 3.0*alpha34*T*T*P*P*P*P     + 4.0*alpha44*T*T*T*P*P*P*P     + 5.0*alpha54*T*T*T*T*P*P*P*P     + 6.0*alpha64*T*T*T*T*T*P*P*P*P 			         + alpha15*P*P*P*P*P   + 2.0*alpha25*T*P*P*P*P*P   + 3.0*alpha35*T*T*P*P*P*P*P   + 4.0*alpha45*T*T*T*P*P*P*P*P   + 5.0*alpha55*T*T*T*T*P*P*P*P*P   + 6.0*alpha65*T*T*T*T*T*P*P*P*P*P 			         + alpha16*P*P*P*P*P*P + 2.0*alpha26*T*P*P*P*P*P*P + 3.0*alpha36*T*T*P*P*P*P*P*P + 4.0*alpha46*T*T*T*P*P*P*P*P*P + 5.0*alpha56*T*T*T*T*P*P*P*P*P*P + 6.0*alpha66*T*T*T*T*T*P*P*P*P*P*P;			// Initialize lengthscale, energy values, and in/decrements at zero //			estimated.l = 0.0;			plus.l      = 0.0;			minus.l     = 0.0;			estimated.thrmv[2] = 0.0;			plus.thrmv[2]      = 0.0;			minus.thrmv[2]     = 0.0;			// Initialize temperature-dependent values at initial lengthscale //			K0 = K0c/(1.0-estimated.tempv);			estimated.thrmv[0] = K0;			plus.thrmv[0]      = K0+DK0;			minus.thrmv[0]     = K0-DK0;			estimated.thrmv[1] = exp(-PISQ*K0*Cc);        //  exp(-PISQ*K0*Cc)        1.0/(exp(PISQ*K0*Cc)-1.0)			plus.thrmv[1]      = exp(-(K0+DK0)*PISQ*Cc);  //  exp(-(K0+DK0)*PISQ*Cc)  1.0/(exp((K0+DK0)*PISQ*Cc)-1.0)			minus.thrmv[1]     = exp(-(K0-DK0)*PISQ*Cc);  //  exp(-(K0-DK0)*PISQ*Cc)  1.0/(exp((K0-DK0)*PISQ*Cc)-1.0)			printf("%17.15g\t%17.15g\t%17.15g\n", estimated.thrmv[1], plus.thrmv[1], minus.thrmv[1]);			// Calculate state-variables at progressively larger length scales, up to coherence length, via Runge-Kutta method (derk) //			while(estimated.thrmv[0]<Kthresh){				// Calculate next estimated state and different temperature (K0-value) test states //				// (to enable a derivative with respect to K0), incrementing lengthscale           //				estimated = derk(IN vltRecRel, INOUT estimated, IN dl, IN N);				plus      = derk(IN vltRecRel, INOUT plus,      IN dl, IN N);				minus     = derk(IN vltRecRel, INOUT minus,     IN dl, IN N);				/* Print intermediate numbers to screen (for bug checking)				j++;				if(j%2000==0){					Kr = estimated.thrmv[0]*exp(-estimated.l);					DeDK0plus = (plus.thrmv[2]-estimated.thrmv[2])/DK0;					DeDK0minus = (estimated.thrmv[2]-minus.thrmv[2])/DK0;					DeDK0 = (DeDK0plus+DeDK0minus)/2;					D2eDK02 = (DeDK0plus-DeDK0minus)/DK0;					cp = -R*estimated.thrmv[2]*((6.65e3)/(rho*a0*a0*a0))*T*((T*alpha-2)*alpha-T*DalphaDT+2*(T*alpha-1)*Da0DT/a0+T*(Da0DT*Da0DT)/(a0*a0)-T*D2a0DT2/a0)					  - R*((6.65e3)/(rho*a0*a0*a0))*((T*alpha+2*T*Da0DT/a0)*K0*DeDK0+K0*K0*D2eDK02)					  - T*P*(4.005e-4/rho)*(alpha*alpha-DalphaDT);					printf(         "%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\n",						1-estimated.tempv, estimated.tempv, estimated.l, estimated.thrmv[0], estimated.thrmv[1], estimated.thrmv[2], Kr, Kr/K0, cp);				}				if(j>10000) j=0; */			}			// Update/set values that depend on state-variables, if not using "Print intermediate numbers..." block of code //			Kr = estimated.thrmv[0]*exp(-estimated.l);			DeDK0plus = (plus.thrmv[2]-estimated.thrmv[2])/DK0;			DeDK0minus = (estimated.thrmv[2]-minus.thrmv[2])/DK0;			DeDK0 = (DeDK0plus+DeDK0minus)/2;			D2eDK02 = (DeDK0plus-DeDK0minus)/DK0;			cp = -R*estimated.thrmv[2]*((6.65e3)/(rho*a0*a0*a0))*T*( (T*alpha-2.0)*alpha - T*DalphaDT + 2.0*(T*alpha-1.0)*Da0DT/a0 + T*(Da0DT*Da0DT)/(a0*a0) - T*D2a0DT2/a0 )			   - R*((6.65e3)/(rho*a0*a0*a0))*( (2.0*T*alpha+2.0*T*Da0DT/a0)*K0*DeDK0 + K0*K0*D2eDK02 )			   - T*P*(4.005e-4/rho)*(alpha*alpha-DalphaDT);			cp01 = -R*estimated.thrmv[2]*((6.65e3)/(rho*a0*a0*a0))*T*( (T*alpha-2.0)*alpha );			cp02 = -R*estimated.thrmv[2]*((6.65e3)/(rho*a0*a0*a0))*T*( -T*DalphaDT );			cp03 = -R*estimated.thrmv[2]*((6.65e3)/(rho*a0*a0*a0))*T*( 2.0*(T*alpha-1.0)*Da0DT/a0 );			cp04 = -R*estimated.thrmv[2]*((6.65e3)/(rho*a0*a0*a0))*T*( T*(Da0DT*Da0DT)/(a0*a0) );			cp05 = -R*estimated.thrmv[2]*((6.65e3)/(rho*a0*a0*a0))*T*( -T*D2a0DT2/a0 );			cp06 = -R*((6.65e3)/(rho*a0*a0*a0))*( (2.0*T*alpha)*K0*DeDK0 );			cp07 = -R*((6.65e3)/(rho*a0*a0*a0))*( (2.0*T*Da0DT/a0)*K0*DeDK0 );			cp08 = -R*((6.65e3)/(rho*a0*a0*a0))*( K0*K0*D2eDK02 );			cp09 = -T*P*(4.005e-4/rho)*(alpha*alpha);			cp10 = -T*P*(4.005e-4/rho)*(-DalphaDT);			/* Print data to screen and output file */			fprintf(outfile,"%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\n",				1-estimated.tempv, estimated.tempv, estimated.l, estimated.thrmv[0], estimated.thrmv[1], estimated.thrmv[2], Kr, Kr/K0, cp, cp01,cp02,cp03,cp04,cp05,cp06,cp07,cp08,cp09,cp10);			printf(         "%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\n",				estimated.tempv, estimated.l, estimated.thrmv[2], Kr, Kr/K0, cp);//			printf(         "%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\n",//				1-estimated.tempv, estimated.tempv, estimated.l, estimated.thrmv[0], estimated.thrmv[1], estimated.thrmv[2], Kr, Kr/K0, cp);//			// Print data to screen and output file ////			fprintf(outfile,"%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\n",//				1-estimated.tempv, estimated.tempv, estimated.l, estimated.thrmv[0], estimated.thrmv[1], estimated.thrmv[2], Kr, Kr/K0, cp);//			printf(         "%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\t%17.15g\n",//				1-estimated.tempv, estimated.tempv, estimated.l, estimated.thrmv[0], estimated.thrmv[1], estimated.thrmv[2], Kr, Kr/K0, cp);		}		// Close output file //		fclose(outfile);	}}// Runge-Kutta 4th order method //void rk4(void (*f)(double, double*, double*, unsigned), double *x, double y[], double h, unsigned n){	int i,j;	double *k[4],*s,temp;	for(i=0;i<4;i++)  k[i] = (double *)calloc(n,sizeof(double));	s = (double *)calloc(n,sizeof(double));	f(*x,y,k[0],n);	for(i=1;i<4;i++){		temp = h*((i+1)/2)/2;		// using integer division trick (times double): ((i+1)/2)/2 = 0.50, 0.50, 1.00 instead of 0.75, 1.00, 1.25		for(j=0;j<n;j++)  s[j] = y[j]+k[i-1][j]*temp;		f(*x+h*(i/2)/2,s,k[i],n);		// using integer division trick (times double): (i/2)/2 = 0.00, 0.50, 0.50 instead of 0.50, 0.75, 1.00	}	for(j=0;j<n;j++)  y[j] += h*(k[0][j]+2.0*(k[1][j]+k[2][j])+k[3][j])/6.0;	*x += h;	for(i=0;i<4;i++)  free((char *) k[i]);	free((char *)s);}// Equilibrium (K,y,e) recursion relations //void EqRecRel(double x, double z[], double dzdx[], unsigned n){	dzdx[0] = z[0]-B*z[0]*z[0]*z[1];//	if( log(z[0]) > 0.0 ) // if ac' > a, set ac' = a (replace log(K[i]) with zero)//		dzdx[1] = z[1]*( 6.0 - PISQ*z[0] );//	else		dzdx[1] = z[1]*( 6.0 - PISQ*z[0]*(1.0-THETA*log(z[0])) );	dzdx[2] = -PI*exp(-3.0*x)*z[1];}//  Program Notes  ////=========================================================================///*In this program, thrmv[2] sometimes represents e, but sometimes it represents de, where e = eimprecise+de.See further documentation (UCLAresearchNotes.pdf, UCLAresearchPrograms.pdf, derk1.c) for elaboration.plus and minus are test states (with test state-variables)*/